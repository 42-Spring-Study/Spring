# 2. 스프링 웹 개발 기초

웹 개발에는 3가지 방법이 있다. 각 방식의 동작 과정을 살펴보자.

# 정적 컨텐츠

파일을 그대로 브라우저에 전달한다. (섹션 1 내용을 참고하자)

## 동작과정

![스크린샷 2024-03-19 오후 6.24.20.png](2%20%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20%E1%84%8B%E1%85%B0%E1%86%B8%20%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%20%E1%84%80%E1%85%B5%E1%84%8E%E1%85%A9%208a671ffc7a0a401994332e365e035017/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-03-19_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_6.24.20.png)

1. 웹 브라우저가 요청을 보내면, 컨테이너가 요청에 매핑되는 컨트롤러 존재하는지 확인한다.
즉, 정적 컨텐츠보다 컨트롤러가 우선권을 가진다
2. 해당 컨트롤러가 존재하지 않으면 스프링은 지정된 위치에 파일이 존재하는지 확인한다
3. 만약 해당 파일이 존재한다면, 브라우저에 그대로 전송한다.

# MVC와 템플릿 엔진

요즘 가장 많이 사용하는 방식으로, 파일을 동적으로 변형해 브라우저에 전달하는 방식이다. (역시, 섹션 1을 참고하자)

## 동작과정

![스크린샷 2024-03-19 오후 6.27.24.png](2%20%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20%E1%84%8B%E1%85%B0%E1%86%B8%20%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%20%E1%84%80%E1%85%B5%E1%84%8E%E1%85%A9%208a671ffc7a0a401994332e365e035017/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-03-19_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_6.27.24.png)

1. 웹브라우저가 요청을 보낸다.
2. 컨테이너가 요청에 매핑되는 컨트롤러가 존재하는지 확인한다.
3. 만약 존재한다면, 스프링 컨테이너는 해당 컨트롤러를 실행시킨다.
4. viewResolver가 view를 찾아, 템플릿 엔진에 처리요청을 한다.
5. 템플릿 엔진이 렌더링한 후, 웹 브라우저에 반환한다.

# API

JSON 방식으로 클라이언트에 데이터만 전달하는 방식이다.  React를 사용하거나, 서버 간 통신할 때 주로 사용한다

## 사용 방법

매핑 함수에 `@ResponseBody`를 사용하고, HTTP Request에서 받아올 param앞에 `@RequestParam("param name")`을 사용한다.

### 문자열 반환

```java
@Controller
public class HelloController {
    @GetMapping("hello")
    public String hello(Model model){...}

    @GetMapping("hello-string")
    @ResponseBody
    public String helloString(@RequestParam("name") String name){
        return "hello " + name;
    }
}
```

컨트롤러에서 반환된 문자열을 전송한다 

⇒ `localhost:8080/hello-string?name=spring` 요청 시 `hello spring` 반환

### 객체 반환

```java
@Controller
public class HelloController {
	   static class Hello {
        private String name;

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }
    }
  
    @GetMapping("hello-api")
    @ResponseBody
    public Hello helloApi(@RequestParam("name") String name){
        Hello hello = new Hello();
        hello.setName(name);
        return hello;
    }
}
```

객체를 JSON으로 변환 해 전송한다

⇒ `localhost:8080/hello-api?name=spring` 요청 시`{"name":"spring"}` 반환

## 동작과정

⇒ 뷰 리졸버를 사용하지 않고, 리턴값을 적절한 형태로 변환 후, HTTP Response의 body에 삽입한다.

![스크린샷 2024-03-19 오후 6.27.42.png](2%20%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20%E1%84%8B%E1%85%B0%E1%86%B8%20%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%20%E1%84%80%E1%85%B5%E1%84%8E%E1%85%A9%208a671ffc7a0a401994332e365e035017/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2024-03-19_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_6.27.42.png)

1. 웹브라우저가 요청을 보낸다.
2. 컨테이너가 요청에 매핑되는 컨트롤러가 존재하는지 확인한다.
3. 만약 존재한다면, 스프링 컨테이너는 해당 컨트롤러를 실행시킨다.
4. 만약 컨트롤러에 @ResponseBody 어노테이션이 부착되어있다면, 리턴된 타입에 일치하는 HttpMesageConverter의 구현체에 리턴값을 전송한다
5. HttpMessageConverter의 구현체가 리턴값을 적절하게 변형하여 브라우저로 전송한다.